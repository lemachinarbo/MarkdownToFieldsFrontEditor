(function () {
  const EDITABLE_CLASS = "fe-editable";
  let activeEditor = null;
  let activeHost = null;
  let activeTarget = null;
  let activeOriginalHtml = null; // Store original HTML before browser modifies it

  function createHost(nextTo) {
    const host = document.createElement("div");
    host.className = "fe-editor-host";
    host.style.minHeight = "1.2em";
    nextTo.parentNode.insertBefore(host, nextTo.nextSibling);
    return host;
  }

  // Floating toolbar implementation
  let toolbarEl = null;
  // Suppress finishEditing's auto-apply when we intentionally replace content
  let suppressFinishEditing = false;
  let allowedCommands = null;
  let allowedBlocks = null;

  function allowMultiBlockFor(el) {
    if (!el) return false;
    const metaEl =
      el && typeof el.closest === "function"
        ? el.closest(".fe-editable") || el
        : el;
    if (!metaEl || !metaEl.dataset) return false;
    if (typeof metaEl.dataset.allowMultiBlock !== "undefined") {
      return (
        metaEl.dataset.allowMultiBlock === "true" ||
        metaEl.dataset.allowMultiBlock === "1"
      );
    }
    const config = window.MarkdownFrontEditorConfig;
    if (config && typeof config.allowMultiBlock !== "undefined") {
      return !!config.allowMultiBlock;
    }
    return false;
  }

  function getFieldMeta(el) {
    if (!el || !el.dataset) return null;
    const typeRaw = (el.dataset.fieldType || "").toLowerCase();
    return {
      type: typeRaw || "block",
      allowMultiBlock: allowMultiBlockFor(el),
    };
  }

  function applyToolbarConstraints(meta) {
    // All field types support all commands - constraints are managed via module config
    allowedCommands = null; // null = all commands allowed
    allowedBlocks = null;

    if (!toolbarEl) return;
    const buttons = toolbarEl.querySelectorAll("button[data-cmd]");
    buttons.forEach((btn) => {
      btn.style.display = "";
      btn.disabled = false;
    });
  }

  function buildExtensions(libs, meta) {
    // Not used - using contentEditable editor instead
    return [];
  }

  function createToolbarEl() {
    if (toolbarEl) return toolbarEl;
    const el = document.createElement("div");
    el.className = "fe-toolbar";
    el.setAttribute("aria-hidden", "true");
    el.style.position = "absolute";
    el.style.display = "none";

    // Get configured buttons from module config
    const configButtons =
      window.MarkdownFrontEditorConfig?.toolbarButtons ||
      "bold,italic,strike,code,paragraph,h1,h2,h3,h4,h5,h6,ul,ol,blockquote,link,clear,save";
    const enabledButtons = new Set(
      configButtons.split(",").map((b) => b.trim()),
    );

    // All possible toolbar buttons
    const allButtons = [
      { cmd: "bold", title: "Bold", label: "<strong>B</strong>" },
      { cmd: "italic", title: "Italic", label: "<em>I</em>" },
      { cmd: "strike", title: "Strikethrough", label: "<s>S</s>" },
      { cmd: "code", title: "Code", label: "<code>&lt;/&gt;</code>" },
      { cmd: "paragraph", title: "Paragraph", label: "Â¶" },
      { cmd: "h1", title: "Heading 1", label: "H1" },
      { cmd: "h2", title: "Heading 2", label: "H2" },
      { cmd: "h3", title: "Heading 3", label: "H3" },
      { cmd: "h4", title: "Heading 4", label: "H4" },
      { cmd: "h5", title: "Heading 5", label: "H5" },
      { cmd: "h6", title: "Heading 6", label: "H6" },
      { cmd: "ul", title: "Bulleted list", label: "â€¢" },
      { cmd: "ol", title: "Numbered list", label: "1." },
      { cmd: "blockquote", title: "Blockquote", label: '"' },
      { cmd: "link", title: "Link", label: "ðŸ”—" },
      { cmd: "clear", title: "Clear formatting", label: "Tx" },
      { cmd: "save", title: "Save", label: "ðŸ’¾" },
    ];

    // Only add buttons that are enabled in config
    el.innerHTML = allButtons
      .filter((btn) => enabledButtons.has(btn.cmd))
      .map(
        (btn) =>
          `<button data-cmd="${btn.cmd}" title="${btn.title}">${btn.label}</button>`,
      )
      .join("");

    // Prevent mousedown from blurring the editor so clicks register
    el.addEventListener("mousedown", (ev) => {
      ev.preventDefault();
    });

    el.addEventListener("click", (ev) => {
      const btn = ev.target.closest("button");
      if (!btn) return;
      const cmd = btn.getAttribute("data-cmd");
      if (cmd === "save") {
        saveContent();
      } else {
        performCommand(cmd);
      }
    });

    document.body.appendChild(el);
    toolbarEl = el;
    return el;
  }

  // Toast helper
  let toastEl = null;
  function getToastEl() {
    if (toastEl) return toastEl;
    const t = document.createElement("div");
    t.className = "fe-toast";
    document.body.appendChild(t);
    toastEl = t;
    return t;
  }

  function showToast(type, msg, timeout = 3000) {
    const t = getToastEl();
    t.className = "fe-toast " + type;
    t.textContent = msg;
    t.style.display = "block";
    setTimeout(() => {
      try {
        t.style.display = "none";
      } catch (e) {}
    }, timeout);
  }

  function toggleStrikeSelection() {
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return false;
    const range = sel.getRangeAt(0);
    if (range.collapsed) {
      // Expand to nearest word if collapsed
      if (range.startContainer && range.startContainer.nodeType === 3) {
        const text = range.startContainer.textContent || "";
        let start = range.startOffset;
        let end = range.startOffset;
        while (start > 0 && /\S/.test(text[start - 1])) start--;
        while (end < text.length && /\S/.test(text[end])) end++;
        if (end > start) {
          range.setStart(range.startContainer, start);
          range.setEnd(range.startContainer, end);
          sel.removeAllRanges();
          sel.addRange(range);
        } else {
          return false;
        }
      } else {
        return false;
      }
    }

    let node = range.commonAncestorContainer;
    if (node.nodeType === 3) node = node.parentNode;
    const strikeEl =
      node && node.closest ? node.closest("del, s, strike") : null;
    if (strikeEl) {
      // Remove strike: unwrap and restore selection
      const parent = strikeEl.parentNode;
      const firstChild = strikeEl.firstChild;
      const lastChild = strikeEl.lastChild;

      while (strikeEl.firstChild)
        parent.insertBefore(strikeEl.firstChild, strikeEl);
      parent.removeChild(strikeEl);

      // Restore selection to unwrapped content
      if (firstChild && lastChild) {
        const newRange = document.createRange();
        try {
          if (firstChild.nodeType === 3) {
            newRange.setStart(firstChild, 0);
          } else {
            newRange.setStartBefore(firstChild);
          }

          if (lastChild.nodeType === 3) {
            newRange.setEnd(lastChild, lastChild.textContent.length);
          } else {
            newRange.setEndAfter(lastChild);
          }

          sel.removeAllRanges();
          sel.addRange(newRange);
        } catch (e) {
          // Silent fail on selection restoration
        }
      }

      return true;
    }

    // Add strike: wrap and restore selection
    const wrapper = document.createElement("del");
    try {
      range.surroundContents(wrapper);
      // Restore selection to wrapped content
      const newRange = document.createRange();
      newRange.selectNodeContents(wrapper);
      sel.removeAllRanges();
      sel.addRange(newRange);
    } catch (e) {
      const frag = range.extractContents();
      wrapper.appendChild(frag);
      range.insertNode(wrapper);
      // Restore selection to wrapped content
      const newRange = document.createRange();
      newRange.selectNodeContents(wrapper);
      sel.removeAllRanges();
      sel.addRange(newRange);
    }
    return true;
  }

  function performCommand(cmd) {
    if (!cmd) return;
    if (allowedCommands && !allowedCommands.has(cmd)) return;

    // Manual formatting via DOM manipulation and execCommand
    if (cmd === "strike") {
      const toggled = toggleStrikeSelection();
      if (toggled) return;
    }

    // Use document.execCommand for common features
    switch (cmd) {
      case "bold":
        document.execCommand("bold");
        break;
      case "italic":
        document.execCommand("italic");
        break;
      case "strike":
        if (!toggleStrikeSelection()) {
          document.execCommand("strikethrough");
        }
        break;
      case "paragraph":
        document.execCommand("formatBlock", false, "p");
        break;
      case "h1":
        document.execCommand("formatBlock", false, "h1");
        break;
      case "h2":
        document.execCommand("formatBlock", false, "h2");
        break;
      case "h3":
        document.execCommand("formatBlock", false, "h3");
        break;
      case "h4":
        document.execCommand("formatBlock", false, "h4");
        break;
      case "h5":
        document.execCommand("formatBlock", false, "h5");
        break;
      case "h6":
        document.execCommand("formatBlock", false, "h6");
        break;
      case "ul":
        document.execCommand("insertUnorderedList");
        break;
      case "ol":
        document.execCommand("insertOrderedList");
        break;
      case "blockquote":
        document.execCommand("formatBlock", false, "blockquote");
        break;
      case "clear":
        document.execCommand("removeFormat");
        document.execCommand("formatBlock", false, "p");
        break;
      case "link": {
        const url = prompt("Enter link URL");
        if (url) document.execCommand("createLink", false, url);
        break;
      }
    }

    // Block-count enforcement: Audit after command to ensure constraint maintained
    if (
      activeEditableEl &&
      !allowMultiBlockFor(activeEditableEl) &&
      countTopLevelBlocks(activeEditableEl) > 1
    ) {
      // If command violated constraint, undo
      document.execCommand("undo");
    }
  }

  function positionToolbar() {
    if (!toolbarEl || (!activeHost && !activeTarget)) return hideToolbar();

    const sel = document.getSelection();
    let rect = null;
    if (sel && sel.rangeCount) {
      const range = sel.getRangeAt(0);
      rect = range.getBoundingClientRect();
    }
    if (!rect) {
      const el = activeHost || activeTarget;
      rect = el.getBoundingClientRect();
    }

    const tb = toolbarEl;
    tb.style.display = "flex";
    const tbRect = tb.getBoundingClientRect();
    const left = rect.left + rect.width / 2 - tbRect.width / 2 + window.scrollX;
    const top = rect.top + window.scrollY - tbRect.height - 8;
    tb.style.left = Math.max(8, left) + "px";
    tb.style.top = Math.max(8, top) + "px";

    // Also reposition slash menu if visible
    if (slashMenuEl && slashMenuEl.style.display !== "none") {
      const mr = slashMenuEl.getBoundingClientRect();
      const left2 = rect.left + rect.width / 2 - mr.width / 2 + window.scrollX;
      const top2 = rect.top + window.scrollY - mr.height - 8;
      slashMenuEl.style.left = Math.max(8, left2) + "px";
      slashMenuEl.style.top = Math.max(8, top2) + "px";
    }
  }

  function createAndShowToolbar(hostOrEl, isTipTap, meta) {
    createToolbarEl();
    applyToolbarConstraints(meta);
    positionToolbar();
    toolbarEl.setAttribute("aria-hidden", "false");
  }

  function hideToolbar() {
    if (!toolbarEl) return;
    toolbarEl.style.display = "none";
    toolbarEl.setAttribute("aria-hidden", "true");
  }

  // Notion-like slash menu and block handle
  let slashMenuEl = null;
  let activeEditableEl = null;
  let activeKeydownListener = null;
  let activeHandleEl = null;

  function createSlashMenu() {
    if (slashMenuEl) return slashMenuEl;
    const menu = document.createElement("div");
    menu.className = "fe-slash-menu";
    menu.style.display = "none";
    const list = document.createElement("ul");

    const items = [
      { id: "paragraph", label: "Paragraph" },
      { id: "h1", label: "Heading 1" },
      { id: "h2", label: "Heading 2" },
      { id: "h3", label: "Heading 3" },
      { id: "h4", label: "Heading 4" },
      { id: "h5", label: "Heading 5" },
      { id: "h6", label: "Heading 6" },
      { id: "ul", label: "Bulleted list" },
      { id: "ol", label: "Numbered list" },
      { id: "quote", label: "Quote" },
      { id: "hr", label: "Divider" },
    ];

    for (const it of items) {
      const li = document.createElement("li");
      li.setAttribute("data-id", it.id);
      li.textContent = it.label;
      li.addEventListener("click", () => {
        applyBlockCommand(it.id);
        hideSlashMenu();
      });
      list.appendChild(li);
    }

    menu.appendChild(list);
    document.body.appendChild(menu);
    slashMenuEl = menu;
    return menu;
  }

  function showSlashMenuAt(rect) {
    const menu = createSlashMenu();
    if (allowedBlocks) {
      const items = menu.querySelectorAll("li[data-id]");
      items.forEach((li) => {
        const id = li.getAttribute("data-id");
        let blockType = null;
        if (id === "paragraph") blockType = "paragraph";
        else if (/^h[1-6]$/.test(id)) blockType = "heading";
        else if (id === "ul" || id === "ol") blockType = "list";
        else if (id === "quote") blockType = "quote";
        else if (id === "hr") blockType = "hr";

        if (!blockType || allowedBlocks.has(blockType)) {
          li.style.display = "";
        } else {
          li.style.display = "none";
        }
      });
    }
    const mr = menu.getBoundingClientRect();
    const left = rect.left + rect.width / 2 - mr.width / 2 + window.scrollX;
    const top = rect.top + window.scrollY - mr.height - 8;
    menu.style.left = Math.max(8, left) + "px";
    menu.style.top = Math.max(8, top) + "px";
    menu.style.display = "block";
  }

  function hideSlashMenu() {
    if (!slashMenuEl) return;
    slashMenuEl.style.display = "none";
  }

  /**
   * Count top-level block elements in the editable content.
   * Block elements: p, h1-h6, ul, ol, blockquote, pre, div, hr
   * (div is treated as block for normalization purposes)
   */
  function countTopLevelBlocks(element) {
    if (!element) return 0;
    let count = 0;
    for (let i = 0; i < element.childNodes.length; i++) {
      const node = element.childNodes[i];
      if (node.nodeType === 1) {
        // Element node
        const tag = node.tagName.toLowerCase();
        if (/^(p|h[1-6]|ul|ol|blockquote|pre|div|hr)$/.test(tag)) {
          count++;
        }
      }
    }
    return count;
  }

  /**
   * Check if pasted HTML would create multiple top-level blocks.
   * Parse HTML and count block-level elements at root level.
   */
  function wouldCreateMultipleBlocks(html) {
    if (!html) return false;
    const temp = document.createElement("div");
    temp.innerHTML = html;
    return countTopLevelBlocks(temp) > 1;
  }

  function applyBlockCommand(cmd) {
    if (!activeEditableEl) return;
    if (allowedBlocks) {
      let blockType = null;
      if (cmd === "paragraph") blockType = "paragraph";
      else if (/^h[1-6]$/.test(cmd)) blockType = "heading";
      else if (cmd === "ul" || cmd === "ol") blockType = "list";
      else if (cmd === "quote") blockType = "quote";
      else if (cmd === "hr") blockType = "hr";

      if (blockType && !allowedBlocks.has(blockType)) return;
    }

    // Use execCommand for block formatting
    switch (cmd) {
      case "paragraph":
        document.execCommand("formatBlock", false, "p");
        break;
      case "h1":
        document.execCommand("formatBlock", false, "h1");
        break;
      case "h2":
        document.execCommand("formatBlock", false, "h2");
        break;
      case "h3":
        document.execCommand("formatBlock", false, "h3");
        break;
      case "h4":
        document.execCommand("formatBlock", false, "h4");
        break;
      case "h5":
        document.execCommand("formatBlock", false, "h5");
        break;
      case "h6":
        document.execCommand("formatBlock", false, "h6");
        break;
      case "ul":
        document.execCommand("insertUnorderedList");
        break;
      case "ol":
        document.execCommand("insertOrderedList");
        break;
      case "quote":
        document.execCommand("formatBlock", false, "blockquote");
        break;
      case "hr":
        document.execCommand("insertHorizontalRule");
        break;
    }

    // Block-count enforcement: Audit after command to ensure constraint maintained
    if (
      activeEditableEl &&
      !allowMultiBlockFor(activeEditableEl) &&
      countTopLevelBlocks(activeEditableEl) > 1
    ) {
      // If command violated constraint, undo
      document.execCommand("undo");
    }
  }

  function onEditableKeydown(ev) {
    // Block-count enforcement: Prevent Enter only if it would create a NEW top-level block
    // Enter is ALLOWED inside multi-item blocks (list items, blockquotes) to create new items/lines
    if (ev.key === "Enter" && ev.type === "keydown") {
      if (
        activeEditableEl &&
        !allowMultiBlockFor(activeEditableEl) &&
        activeEditableEl &&
        countTopLevelBlocks(activeEditableEl) >= 1
      ) {
        const sel = document.getSelection();
        if (sel && sel.rangeCount > 0) {
          let node = sel.anchorNode || sel.focusNode;
          if (node && node.nodeType === 3) node = node.parentNode;

          // Check if cursor is inside a multi-item block context
          // These contexts allow Enter to create new items/lines without creating new top-level blocks
          let current = node;
          while (current && current !== activeEditableEl) {
            const tag = current.tagName?.toLowerCase();

            // Inside list item: Enter creates new <li>, stays in list block âœ“
            if (tag === "li") {
              // Allow Enter but audit after to catch list-exit case
              setTimeout(() => {
                if (
                  activeEditableEl &&
                  countTopLevelBlocks(activeEditableEl) > 1
                ) {
                  document.execCommand("undo");
                }
              }, 0);
              return;
            }

            // Inside blockquote: Enter creates new line, stays in quote block âœ“
            if (tag === "blockquote") {
              // Allow Enter but audit after
              setTimeout(() => {
                if (
                  activeEditableEl &&
                  countTopLevelBlocks(activeEditableEl) > 1
                ) {
                  document.execCommand("undo");
                }
              }, 0);
              return;
            }

            current = current.parentNode;
          }

          // Not in multi-item context: we're in a paragraph/heading at top-level
          // Enter would create a new top-level block, so block it
          ev.preventDefault();
          return;
        }
      }
    }

    if (ev.key === "/" && ev.type === "keydown") {
      // Only when selection collapsed
      const sel = document.getSelection();
      if (!sel || !sel.isCollapsed) return;
      // Show menu anchored at caret
      ev.preventDefault();
      const range = sel.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      showSlashMenuAt(rect);
    }

    // Escape hides menu
    if (ev.key === "Escape") hideSlashMenu();
  }

  function createHandle(host) {
    if (activeHandleEl) return activeHandleEl;
    const btn = document.createElement("button");
    btn.className = "fe-handle";
    btn.type = "button";
    btn.innerHTML = "â‰¡";
    btn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const rect = host.getBoundingClientRect();
      showSlashMenuAt(rect);
    });
    host.style.position = "relative";
    host.insertBefore(btn, host.firstChild);
    activeHandleEl = btn;
    return btn;
  }

  function removeHandle() {
    if (!activeHandleEl) return;
    if (activeHandleEl.parentNode)
      activeHandleEl.parentNode.removeChild(activeHandleEl);
    activeHandleEl = null;
  }

  function destroyEditor() {
    if (!activeEditor) return;
    try {
      if (typeof activeEditor.destroy === "function") activeEditor.destroy();
    } catch (e) {
      /* ignore */
    }

    try {
      if (activeHost && activeHost.parentNode)
        activeHost.parentNode.removeChild(activeHost);
    } catch (e) {
      // Error removing activeHost
    }

    try {
      if (activeTarget && typeof activeTarget.style !== "undefined")
        activeTarget.style.display = "";
    } catch (e) {
      // Error setting activeTarget display
    }

    // If we used contentEditable fallback, clear that state
    try {
      const at = activeTarget;
      if (at && typeof at.removeAttribute === "function") {
        try {
          at.removeAttribute("contenteditable");
        } catch (_) {}
        try {
          at.removeAttribute("data-fe-editing");
        } catch (_) {}
      }
    } catch (e) {
      // Error clearing activeTarget attributes
    }

    // Cleanup toolbar, slash menu, handle and listeners
    hideToolbar();
    hideSlashMenu();
    removeHandle();
    try {
      document.removeEventListener("selectionchange", positionToolbar);
    } catch (e) {}
    if (activeEditableEl && activeKeydownListener) {
      activeEditableEl.removeEventListener("keydown", activeKeydownListener);
    }

    activeEditor = null;
    activeHost = null;
    activeTarget = null;
    activeOriginalHtml = null;
    activeEditableEl = null;
    activeKeydownListener = null;
  }

  function finishEditing() {
    if (suppressFinishEditing) {
      suppressFinishEditing = false;
      return;
    }
    if (!activeEditor || !activeTarget) return;
    // TipTap editor exposes getHTML, while fallback uses innerHTML directly
    const html =
      typeof activeEditor.getHTML === "function"
        ? activeEditor.getHTML()
        : activeTarget.innerHTML;
    destroyEditor();
    if (html) activeTarget.innerHTML = html;
  }

  function protectBrTagsForEditor(html) {
    // Replace <br> with a zero-width space marker that won't be restructured
    // Use a special marker that we can detect and restore
    console.log("protectBrTagsForEditor INPUT:", html);
    let index = 0;
    const result = html.replace(/<br\s*\/?>/gi, () => {
      return `\uFEFF__MD_BR_${index++}__\uFEFF`;
    });
    console.log("protectBrTagsForEditor OUTPUT:", result);
    return result;
  }

  function restoreBrTagsFromEditor(html) {
    // Restore <br> tags after editing
    console.log("restoreBrTagsFromEditor INPUT:", html);
    const result = html.replace(/\uFEFF__MD_BR_(\d+)__\uFEFF/g, "<br>");
    console.log("restoreBrTagsFromEditor OUTPUT:", result);
    return result;
  }

  function fallbackAttach(element) {
    // Simple contentEditable fallback
    // For multi-line fields, ensure we attach to the wrapper, not nested elements
    const wrapper = element.closest(".fe-editable") || element;
    activeTarget = wrapper;

    // For multi-line fields, create a proper textarea-like editable
    const isMultiLine = allowMultiBlockFor(wrapper);
    if (isMultiLine) {
      // Create editable div that preserves all HTML structure
      const editableDiv = document.createElement("div");
      editableDiv.setAttribute("contenteditable", "true");
      editableDiv.setAttribute("data-fe-editing", "1");
      // Protect <br> tags before loading into contentEditable
      editableDiv.innerHTML = protectBrTagsForEditor(wrapper.innerHTML);

      // Store original HTML to restore on cancel
      activeOriginalHtml = wrapper.innerHTML;

      // Replace wrapper content with editable
      wrapper.innerHTML = "";
      wrapper.appendChild(editableDiv);
      editableDiv.focus();

      activeEditableEl = editableDiv;
    } else {
      // For single-line fields, also protect <br> tags before contentEditable
      // Save original HTML for restoration on cancel
      activeOriginalHtml = wrapper.innerHTML;
      // Protect <br> tags in place
      wrapper.innerHTML = protectBrTagsForEditor(wrapper.innerHTML);
      wrapper.setAttribute("contenteditable", "true");
      wrapper.setAttribute("data-fe-editing", "1");
      wrapper.focus();
      activeEditableEl = wrapper;
    }

    // Add keydown handler for slash menu
    activeKeydownListener = onEditableKeydown;
    activeEditableEl.addEventListener("keydown", activeKeydownListener);

    // Block-count enforcement: Guard paste to prevent multi-block content
    wrapper.addEventListener("paste", (ev) => {
      const allowMulti = allowMultiBlockFor(wrapper);

      ev.preventDefault();

      let html = "";
      if (ev.clipboardData) {
        // Try to get HTML first, fallback to text
        html = ev.clipboardData.getData("text/html");
        if (!html) {
          html = ev.clipboardData.getData("text/plain");
        }
      }

      // For single-block fields: reject pasted content with newlines
      if (!allowMulti) {
        // Check for actual newlines in plain text
        if (/\n|\r/.test(html)) {
          return;
        }
        // Check for <br> tags in HTML
        if (/<br\s*\/?>/i.test(html)) {
          return;
        }
        // Check if pasted content would create multiple blocks
        if (wouldCreateMultipleBlocks(html)) {
          return;
        }
      }

      // Insert paste content
      if (html) {
        document.execCommand("insertHTML", false, html);
      }
    });

    function onBlur() {
      wrapper.removeEventListener("blur", onBlur);
      try {
        destroyEditor();
      } catch (e) {
        // destroyEditor error on blur
      }
    }
    wrapper.addEventListener("blur", onBlur);
    activeEditor = { getHTML: () => activeEditableEl.innerHTML };
  }

  function attachTo(element) {
    if (activeEditor) return; // single-editor restriction
    const meta = getFieldMeta(element);

    // Use contentEditable editor
    fallbackAttach(element);
    createAndShowToolbar(element, false, meta);
    document.addEventListener("selectionchange", positionToolbar);
  }
  let isSaving = false;

  function normalizeHtmlForMarkdown(html) {
    if (!html) return html;

    // Protect <br> tags in headings before DOM parsing
    // Browser parsing will split <h1>Title<br>Test</h1> into <h1>Title</h1><br>Test
    const brPlaceholder = "___MD_BR_PLACEHOLDER___";
    html = html.replace(
      /<(h[1-6][^>]*)>([^<]*)<br\s*\/?>/gi,
      (match, tag, content) => {
        return `<${tag}>${content}${brPlaceholder}`;
      },
    );

    // Restore encoded strike tags so converter can handle them
    html = html.replace(
      /&lt;(\/?)(strike|s)([^&]*?)&gt;/gi,
      (m, slash, tag, attrs) => `<${slash}${tag}${attrs}>`,
    );

    const root = document.createElement("div");
    root.innerHTML = html;

    const decodeHtml = (value) => {
      if (!value) return "";
      const tmp = document.createElement("textarea");
      tmp.innerHTML = value;
      return tmp.value;
    };

    // Unwrap spans and drop inline styles that break markdown conversion
    root.querySelectorAll("span").forEach((span) => {
      const frag = document.createDocumentFragment();
      while (span.firstChild) frag.appendChild(span.firstChild);
      span.replaceWith(frag);
    });

    // Normalize strike tags to <del> for markdown conversion
    root.querySelectorAll("strike, s").forEach((el) => {
      const del = document.createElement("del");
      del.innerHTML = el.innerHTML;
      el.replaceWith(del);
    });

    // Convert browser-inserted <div> tags to <p> tags for proper markdown conversion
    root.querySelectorAll("div").forEach((div) => {
      // Skip if it has child block elements (it's a container)
      const hasBlockChildren = Array.from(div.children).some((child) => {
        const tag = child.tagName.toLowerCase();
        return [
          "p",
          "div",
          "ul",
          "ol",
          "blockquote",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
        ].includes(tag);
      });

      if (!hasBlockChildren) {
        const p = document.createElement("p");
        // Copy innerHTML, but if empty, at least make it a line break
        p.innerHTML = div.innerHTML || "<br>";
        div.replaceWith(p);
      }
    });

    // Remove inline styles that can leak into markdown
    root.querySelectorAll("[style]").forEach((el) => {
      el.removeAttribute("style");
    });

    const buildBlocksFromLines = (lines, doc) => {
      const frag = doc.createDocumentFragment();
      let currentType = null;
      let currentEl = null;

      const flush = () => {
        if (currentEl) frag.appendChild(currentEl);
        currentEl = null;
        currentType = null;
      };

      for (const raw of lines) {
        const line = (raw || "").trim();
        if (!line) {
          flush();
          continue;
        }

        let type = "p";
        let content = line;
        if (/^>\s*/.test(line)) {
          type = "quote";
          content = line.replace(/^>\s*/, "");
        } else if (/^\d+\.\s+/.test(line)) {
          type = "ol";
          content = line.replace(/^\d+\.\s+/, "");
        } else if (/^[-*]\s+/.test(line)) {
          type = "ul";
          content = line.replace(/^[-*]\s+/, "");
        }

        if (type === "p") {
          flush();
          const p = doc.createElement("p");
          p.textContent = content;
          frag.appendChild(p);
          continue;
        }

        if (type !== currentType) {
          flush();
          if (type === "ol" || type === "ul") {
            currentEl = doc.createElement(type);
          } else if (type === "quote") {
            currentEl = doc.createElement("blockquote");
          }
          currentType = type;
        }

        if (type === "ol" || type === "ul") {
          const li = doc.createElement("li");
          li.textContent = content;
          currentEl.appendChild(li);
        } else if (type === "quote") {
          const p = doc.createElement("p");
          p.textContent = content;
          currentEl.appendChild(p);
        }
      }

      flush();
      return frag;
    };

    const getLinesFromElement = (el) => {
      if (!el) return [];
      const innerText = typeof el.innerText === "string" ? el.innerText : "";
      if (innerText.trim()) {
        return innerText
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter(Boolean);
      }

      const html = el.innerHTML || "";
      const normalized = html
        .replace(/<br\s*\/?>/gi, "\n")
        .replace(/<\/p>/gi, "\n")
        .replace(/<\/div>/gi, "\n");
      const text = decodeHtml(normalized.replace(/<[^>]+>/g, ""));
      return text
        .split(/\r?\n/)
        .map((l) => l.trim())
        .filter(Boolean);
    };

    const replaceElementWithLines = (el) => {
      const lines = getLinesFromElement(el);
      if (!lines.length) return;

      const hasMarkers = lines.some((l) =>
        /^(?:\d+\.\s+|[-*]\s+|>\s*)/.test(l),
      );
      if (!hasMarkers) return;

      const frag = buildBlocksFromLines(lines, el.ownerDocument);
      if (frag && frag.childNodes.length) el.replaceWith(frag);
    };

    // Split headings containing <br> into separate blocks
    root.querySelectorAll("h1,h2,h3,h4,h5,h6").forEach((h) => {
      if (!/<br\s*\/?>/i.test(h.innerHTML)) return;
      const parts = h.innerHTML
        .split(/<br\s*\/?>/i)
        .map((p) => p.trim())
        .filter(Boolean);
      if (parts.length <= 1) return;

      h.innerHTML = parts.shift();
      const lines = parts
        .map((p) => p.replace(/<[^>]+>/g, "").trim())
        .filter(Boolean);
      if (!lines.length) return;

      const frag = buildBlocksFromLines(lines, h.ownerDocument);
      h.after(frag);
    });

    // Convert divs/paragraphs that contain list/quote-like lines
    root.querySelectorAll("div, p").forEach((el) => {
      replaceElementWithLines(el);
    });

    // Force conversion for plain text div blocks with list/quote markers
    root.querySelectorAll("div").forEach((el) => {
      if (el.children && el.children.length) return;
      const lines = getLinesFromElement(el);
      if (!lines.length) return;
      const hasMarkers = lines.some((l) =>
        /^(?:\d+\.\s+|[-*]\s+|>\s*)/.test(l),
      );
      if (!hasMarkers) return;
      const frag = buildBlocksFromLines(lines, el.ownerDocument);
      if (frag && frag.childNodes.length) el.replaceWith(frag);
    });

    return root.innerHTML.replace(new RegExp(brPlaceholder, "g"), "<br>");
  }

  async function saveContent() {
    if (isSaving) {
      showToast("error", "Save in progress");
      return;
    }
    isSaving = true;
    // disable save button to prevent duplicates
    const disableSaveBtn = () => {
      if (toolbarEl) {
        const btn = toolbarEl.querySelector('button[data-cmd="save"]');
        if (btn) btn.disabled = true;
      }
    };
    const enableSaveBtn = () => {
      if (toolbarEl) {
        const btn = toolbarEl.querySelector('button[data-cmd="save"]');
        if (btn) btn.disabled = false;
      }
    };
    disableSaveBtn();

    try {
      // For multi-line container fields, extract plain text to avoid HTML artifacts
      // For single-block fields, use HTML for validation and conversion
      const isMultiLine = allowMultiBlockFor(activeTarget);
      let html = "";
      let plainText = "";

      try {
        let sourceElement = null;

        if (activeEditor && typeof activeEditor.getHTML === "function") {
          html = activeEditor.getHTML();
          if (activeTarget) {
            sourceElement = activeTarget;
          }
          if (isMultiLine && typeof activeEditor.getText === "function") {
            plainText = activeEditor.getText();
          }
          console.log(
            "[FE] saveContent - activeEditor path, activeTarget:",
            activeTarget ? activeTarget.tagName : "null",
            "sourceElement:",
            sourceElement ? sourceElement.tagName : "null",
            "html.length:",
            html.length,
          );
        } else if (activeHost) {
          const shim = activeHost.querySelector(".tiptap-shim-editable");
          const editableChild = activeHost.querySelector("[contenteditable]");
          if (shim) {
            sourceElement = shim;
            html = shim.innerHTML;
          } else if (editableChild) {
            sourceElement = editableChild;
            html = editableChild.innerHTML;
          } else {
            sourceElement = activeHost;
            html = activeHost.innerHTML || "";
          }
        } else if (activeTarget) {
          sourceElement = activeEditableEl || activeTarget;
          html = sourceElement.innerHTML || "";
        } else {
          const el = document.querySelector(".fe-editable");
          if (el) {
            sourceElement = el;
            html = el.innerHTML || "";
          }
        }

        // Restore <br> tags that were protected for contentEditable
        console.log("BEFORE restoreBrTagsFromEditor:", html);
        html = restoreBrTagsFromEditor(html);
        console.log("AFTER restoreBrTagsFromEditor:", html);

        // For multi-line fields, extract plain text with preserved line breaks
        if (isMultiLine && sourceElement) {
          plainText =
            sourceElement.innerText || sourceElement.textContent || "";
        }
      } catch (e) {
        const sourceEl = activeEditableEl || activeTarget;
        html = sourceEl ? sourceEl.innerHTML : "";
        if (isMultiLine && sourceEl) {
          plainText = sourceEl.innerText || sourceEl.textContent || "";
        }
      }

      // Validate block-count constraint: reject saves with multiple top-level blocks
      if (!allowMultiBlockFor(activeTarget)) {
        try {
          const temp = document.createElement("div");
          temp.innerHTML = html;
          if (countTopLevelBlocks(temp) > 1) {
            enableSaveBtn();
            isSaving = false;
            showToast(
              "error",
              "Cannot save: field must contain exactly one block",
            );
            return;
          }

          // Note: <br> tags are allowed (from markdown source or explicit user HTML)
          // The Enter key guard prevents actual line breaks from being created
          // If validation fails on the backend, it will return an error
        } catch (e) {
          /* ignore */
        }
      }

      // Strip known client chrome (handles, toolbar) before sending
      try {
        html = html.replace(
          /<button[^>]*class=["']?[^"']*fe-handle[^"']*["']?[^>]*>[\s\S]*?<\/button>/gi,
          "",
        );
        html = html.replace(
          /<div[^>]*class=["']?[^"']*fe-toolbar[^"']*["']?[^>]*>[\s\S]*?<\/div>/gi,
          "",
        );
        html = html.replace(/ data-fe-editing="[^"]*"/g, "");
      } catch (e) {
        /* ignore */
      }

      // Ensure inline breaks are real <br> tags before posting
      try {
        html = html.replace(
          /<md-inline-break\b[^>]*><\/md-inline-break>/gi,
          "<br>",
        );
      } catch (e) {
        /* ignore */
      }

      // Normalize HTML before sending to backend (remove spans, convert divs, etc.)
      try {
        html = normalizeHtmlForMarkdown(html);
      } catch (e) {
        console.error("[FE] normalizeHtmlForMarkdown error:", e);
      }

      // Validate non-empty content (allow images/media)
      const contentToValidate = isMultiLine && plainText ? plainText : html;
      if (!contentToValidate || !contentToValidate.trim()) {
        // Check for media even if no text
        const tmp = document.createElement("div");
        tmp.innerHTML = html || "";
        const hasMedia = !!tmp.querySelector("img,video,iframe,svg");
        if (!hasMedia) {
          showToast("error", "Nothing to save");
          return;
        }
      }

      // fetch CSRF token
      let tokenName = null,
        tokenValue = null;
      try {
        const resp = await fetch(
          location.pathname + "?markdownFrontEditorToken=1",
          { credentials: "same-origin" },
        );
        if (resp.ok) {
          const text = await resp.text();
          const tmp = document.createElement("div");
          tmp.innerHTML = text;
          const inp = tmp.querySelector("input[type=hidden]");
          if (inp) {
            tokenName = inp.getAttribute("name");
            tokenValue = inp.value;
          }
        }
      } catch (e) {
        /* ignore token fetch error */
      }

      const body = new URLSearchParams();

      // Always send HTML for conversion to markdown
      // This preserves lists, formatting, etc.
      body.append("html", html);

      // Debug payload details for server-side tracing
      body.append("debug_isMultiLine", isMultiLine ? "1" : "0");
      body.append("debug_plainTextLen", String(plainText.length || 0));
      body.append("debug_htmlLen", String(html.length || 0));

      if (tokenName) body.append(tokenName, tokenValue);
      // Include block identifier and page id when available for single-block replacement
      const mdName =
        activeTarget && activeTarget.dataset && activeTarget.dataset.mdName
          ? activeTarget.dataset.mdName
          : null;
      const pageId =
        activeTarget && activeTarget.dataset && activeTarget.dataset.page
          ? activeTarget.dataset.page
          : null;
      if (mdName) body.append("mdName", mdName);
      if (pageId) body.append("pageId", pageId);

      const res = await fetch(
        location.pathname + "?markdownFrontEditorSave=1",
        {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          credentials: "same-origin",
          body: body.toString(),
        },
      );

      let json = null;
      try {
        json = await res.json();
      } catch (e) {
        json = null;
      }

      if (res.ok && json && json.status === 1) {
        showToast("success", json.message || "Saved");
        if (json.html) {
          try {
            suppressFinishEditing = true;
            destroyEditor();
          } catch (e) {}
          const hostEl =
            document.querySelector(
              `.fe-editable[data-md-name="${mdName}"][data-page="${pageId}"]`,
            ) || activeTarget;
          if (hostEl) {
            try {
              hostEl.innerHTML = json.html;
            } catch (e) {}
            setTimeout(() => {
              try {
                hostEl.innerHTML = json.html;
              } catch (e) {}
            }, 120);
          }
        } else {
          try {
            destroyEditor();
          } catch (e) {}
        }
      } else {
        showToast(
          "error",
          "Save failed: " +
            (json && json.error ? json.error : res.statusText || "unknown"),
        );
      }
    } catch (e) {
      showToast("error", "Save failed: " + e.message);
    } finally {
      isSaving = false;
      enableSaveBtn();
    }
  }
  document.addEventListener("DOMContentLoaded", () => {
    document.body.addEventListener("dblclick", (ev) => {
      const el = ev.target.closest("." + EDITABLE_CLASS);
      if (!el) return;
      attachTo(el);
    });

    // Escape key cancels edit
    document.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape" && activeEditor) {
        destroyEditor();
      }
    });
  });
})();
